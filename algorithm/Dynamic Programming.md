# Dynamic Programming 動態規劃

作者: 神里綾華的狗

* overview  
`動態規劃` 動態規劃（英語：Dynamic programming，簡稱DP）是一種在數學、管理科學、電腦科學、經濟學和生物資訊學中使用的，通過把原問題分解為相對簡單的子問題的方式求解複雜問題的方法。


#### 講人話就是
**將經常重複的值給`紀錄` **當要再次使用此值計算時就不用**再次計算**==>取出值即可使用

---
* 說明  

動態規劃常常適用於有**重疊子問題**和**最佳子結構性質**的問題，動態規劃方法**所耗時間往往遠少於樸素解法**。

動態規劃在尋找有很多重疊子問題的情況的最佳解時有效。它將問題重新組合成子問題。為了**避免多次解決這些子問題**，它們的結果都逐漸被計算並被儲存，從簡單的問題直到整個問題都被解決。因此，動態規劃`儲存遞迴`時的結果，因而不會在解決同樣的問題時花費不必要的時間。

動態規劃**只能應用於有最佳子結構的問題**。最佳子結構的意思是局部最佳解能決定全域最佳解（對有些問題這個要求並不能完全滿足，故有時需要引入一定的近似）。簡單地說，問題能夠分解成子問題來解決。

---

以[費式數列](https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0)舉例:

![](https://github.com/archie0732/c-library/blob/main/picture/20140592ecvY7JHRxJ.png)

如上圖，當我們要計算F(3)時必須要先經過F(1)與F(2)，而在F(4)時則要經過F(3)與F(2)   
在`一般解`的情況下==>又可以看成F(4)要經過F(1)、F(2)、F(2)  
這時如果使用`動態規劃`下就 **會在算完F(3)時紀錄(儲存)** 等到需要F(3)時就 **免去再次計算F(3)**

***

* 舉例計算F(5)，已知F(1)、F(2)值且**F(n)=F(n-1)+F(n-2)**
  
**一般解**的情況下:
>F(5)=F(4)+F(3) 沒有F(3)與F(4)值，再次計算  
>F(5)=[F(3)+F(2)]+[F(1)+F(2)]又因為沒有F(3)值，再次計算F(3)  
>F(5)=[F(2)+F(1)+F(2)]+[F(1)+F(2])
會發現:**F(3)重複了好幾次**非常的花時間


如果這時使用**動態規劃**:
>F(3)=F(1)+F(2)==>紀錄F(3)  
>F(4)=F(3)+F(2)==>提取F(3)，得值紀錄F(4)  
>F(5)=F(4)+F(3)==>提取F(4)、F(3)，得值紀錄F(5)  
>得所求: F(5)  

會發現省去了很多的重複計算

---
## 常用於問題:
1. [費式數列](https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0)
2. [平衡樹]()
3. [背包問題]()

***
## 使用方法


* 所需技能
> [陣列arry ]()  
> [演算法algorithm(非必要)]()

### 演示:求1到10的階層  
  

1. 暴力解
```cpp
#include <iostream>

using namespace std;

int main(int argc, char const *argv[])
{

    for (int j = 2; j <= 10; j++)//j排序從2!開始到10!
    {
        int a = 1;
        for (int i = 2; i <= j; i++)
        {
            a = a * i; // 每次計算都是重新重1開始乘到j
        }
        cout << a << endl;
    }
    return 0;
}

```
看了就會發現浪費了許多的時間去算**重複的數**(例如算5!時還要1 * 2 * 3 * 4 * 5)

2. 使用動態規劃:  
```cpp
#include <iostream>

using namespace std;

int main(int argc, char const *argv[])
{

    int a[11];
    a[0] = 0;
    a[1] = 1;
    for (int i = 2; i < 11; i++) // i from 2 ==>3==>4
    {
        a[i] = a[i - 1] * i; // 即i!=(i-1)!*i 儲存1到10階，當有需要時取出避免浪費資源在算一次
    }
    for (int i = 2; i < 11; i++)
    {
        cout << a[i] << endl;
    }
    return 0;
}

```

會發現同樣計算5!不用再重1乘到5直接用**4! * 5**(因為有紀錄4!)



***

### 關於空間複雜度與時間複雜度

* 在經典問題**費式數列**中   

分別表示使用`動態規劃`與`樸素解法`(暴力解)的空間複雜度   
|      |空間複雜度|時間複雜度|
|------|---------|---------|
|動態規劃|O(N)|O(N)|
|暴力解|o(N)|2^N|

會發現使用動態規劃將直**紀錄**且需要時再次**取出**比每次要重複計算**重複的值**還要快速

但在問題相較簡單時:  
會發現這時候暴力解更好用了(省去空間紀錄)




