# Dynamic Programming

* overview  
`動態規劃` 動態規劃（英語：Dynamic programming，簡稱DP）是一種在數學、管理科學、電腦科學、經濟學和生物資訊學中使用的，通過把原問題分解為相對簡單的子問題的方式求解複雜問題的方法。


#### 講人話就是
**將經常重複的值給`紀錄` **當要再次使用此值計算時就不用**再次計算**==>取出值即可使用

---
* 說明  

動態規劃常常適用於有**重疊子問題**和**最佳子結構性質**的問題，動態規劃方法**所耗時間往往遠少於樸素解法**。

動態規劃在尋找有很多重疊子問題的情況的最佳解時有效。它將問題重新組合成子問題。為了**避免多次解決這些子問題**，它們的結果都逐漸被計算並被儲存，從簡單的問題直到整個問題都被解決。因此，動態規劃`儲存遞迴`時的結果，因而不會在解決同樣的問題時花費不必要的時間。

動態規劃**只能應用於有最佳子結構的問題**。最佳子結構的意思是局部最佳解能決定全域最佳解（對有些問題這個要求並不能完全滿足，故有時需要引入一定的近似）。簡單地說，問題能夠分解成子問題來解決。

---
常用於問題:
1. [費布納西數列]()
2. [平衡樹]()
3. [背包問題]()

***
## 使用方法


* 所需技能
> [陣列arry ]()  
> [演算法algorithm(非必要)]()

* 演示
在**陣列**中儲存**常用元素**  
EX:(求階層最大至10階)
1. 暴力解
```cpp
#include <iostream>

using namespace std;

int main(int argc, char const *argv[])
{
    int a = 1, n;
    cin >> n;

    for (int i = 2; i <= n; i++)
    {
        a = a * i;//每次計算都是重新重1開始乘到n
    }
    cout << a;
    return 0;
}

```
3. 使用動態規劃:  
```cpp
#include <iostream>

using namespace std;

int main(int argc, char const *argv[])
{
    int n;
    int a[10];
    a[0] = 0;
    a[1] = 1;
    for (int i = 2; i < 11; i++)//i from 2 ==>3==>4
    {
        a[i] = a[i - 1] * i;即i!=(i-1)!*i 儲存1到10階，當有需要時取出避免浪費資源在算一次
    }
    cout << a[n];//給出n
    return 0;
}

```





***

### 關於空間複雜度與時間複雜度

* 在經典問題**費布納西數列**中   

分別表示使用`動態規劃`與`樸素解法`(暴力解)的空間複雜度   
|      |空間複雜度|時間複雜度|
|------|---------|---------|
|動態規劃|O(N)|O(N)|
|暴力解|o(N)|2^N|

會發現使用動態規劃將直**紀錄**且需要時再次**取出**比每次要重複計算**重複的值**還要快速

* 但在於相對基本的題目(以**N!** 舉例)  

|   |空間複雜度|時間複雜度|
|---|---------|---------|
|動態規劃|O(N)|O(N)|
|暴力解|O(N)|O(1)|
 
會發現這時候暴力解更好用了(速度較快)




