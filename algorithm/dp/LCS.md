# Longest Common Subsequence (LCS / 最大公共子序列 )

#### 前言

LCS 式DP裡最重要也是最核心的思想，題目與變化題有很多，也可以在[LeetCode](https://leetcode.com/problemset/)上寫變化題，這裡先講最簡單的基本法

**請先確定已經了解[動態規劃](https://github.com/archie0732/c-library/blob/main/algorithm/Dynamic%20Programming.md)的精神與核心再看此文喔!


***

![](https://i.pinimg.com/736x/82/c7/10/82c710d8aa511d0bdce46866c89c1fd4.jpg)  

***

假如果們有兩個字串要找到其最長的公共排序(出現順序一樣，不用連在一起)

* apple
* people

通過簡略的計算可以得到==>`pple`是最長的公有排序數量     

即
* a`pple`
* `p`eo`ple`

**ANS:** 4


#### 再程式碼裡實現

這時就可以想到使用DP了

首先
1. DP的主要精神==>建立表格

[可以使用這個自己體驗](https://alchemist-al.com/algorithms/longest-common-subsequence)


意思 ==> 空白對空白==> 0 ，空白對 a (不同，即為 0 )

依照這個意思將第一行與第一列填滿(全填0)

|     |     |   a |   p  |  p  |  l  |  e  |
|-----|-----|------|------|-----|-----|-----| 
|     |   0 |　0   | 0    | 0    |    0| 0    |
|  p  |    0 |      |     |      |     |     |
| e   |     0|      |     |      |     |     |
| o   |     0|      |     |      |     |     |
| p   |    0 |      |     |      |     |     |
| l   |     0|      |     |      |     |     |
| e   |     0|      |     |      |     |     |

接下來由`people`的每個字元依序遍歷`apple`的每個字元  
* 如果字元相同==> 該格為該格的斜上數+1
* 如果不同 ==> 取上方與左方的最大值填入

|     |     |   a |   p  |  p  |  l  |  e  |
|-----|-----|------|------|-----|-----|-----| 
|     |   0 |　0   | 0    | 0    |    0| 0    |
|  p  |    0 |     0 | 1     |     1 |  1    | 1     |
| e   |     0|      |     |      |     |     |
| o   |     0|      |     |      |     |     |
| p   |    0 |      |     |      |     |     |
| l   |     0|      |     |      |     |     |
| e   |     0|      |     |      |     |     |

稍微解釋一下:  
`people`的`p`遍歷`apple`  
>當遇到 a 時，不同找上方與左方的最大值==> 0  
>當遇到 p 時，相同斜上方的數+1 ==> 1  
>當遇到 p 時，相同斜上方的數+1 ==> 1  
>當遇到 l 時，不同找上方與左方的最大值==> 1  
>當遇到 e 時，不同找上方與左方的最大值==> 1


接下來是第二行也就是`people`的`e`  

方法如下:  

|     |     |   a |   p  |  p  |  l  |  e  |
|-----|-----|------|------|-----|-----|-----| 
|     |   0 |　0   | 0    | 0    |    0| 0    |
|  p  |    0 |     0 | 1     |     1 |  1    | 1     |
| e   |     0|     0 | 1    | 1     | 1    | 2    |
| o   |     0|      |     |      |     |     |
| p   |    0 |      |     |      |     |     |
| l   |     0|      |     |      |     |     |
| e   |     0|      |     |      |     |     |

>當遇到 a 時，不同找上方與左方的最大值==> 0   
>當遇到 p 時，不同找上方與左方的最大值 ==> 1  
>當遇到 p 時，不同找上方與左方的最大值 ==> 1  
>當遇到 l 時，不同找上方與左方的最大值==> 1  
>當遇到 e 時，相同斜上數+1==> 2


第三行(`o`)  

|     |     |   a |   p  |  p  |  l  |  e  |
|-----|-----|------|------|-----|-----|-----| 
|     |   0 |　0   | 0    | 0    |    0| 0    |
|  p  |    0 |     0 | 1     |     1 |  1    | 1     |
| e   |     0|     0 | 1    | 1     | 1    | 2    |
| o   |     0|   0   |  1   | 1     | 1    | 2    |
| p   |    0 |      |     |      |     |     |
| l   |     0|      |     |      |     |     |
| e   |     0|      |     |      |     |     |


第五行(`p`)  

|     |     |   a |   p  |  p  |  l  |  e  |
|-----|-----|------|------|-----|-----|-----| 
|     |   0 |　0   | 0    | 0    |    0| 0    |
|  p  |    0 |     0 | 1     |     1 |  1    | 1     |
| e   |     0|     0 | 1    | 1     | 1    | 2    |
| o   |     0|   0   | 1    |  1    | 1    | 2    |
| p   |    0 |     0 | 1    | 2     |  2   | 2    |
| l   |     0|      |     |      |     |     |
| e   |     0|      |     |      |     |     |

第六行(`l`)  

|     |     |   a |   p  |  p  |  l  |  e  |
|-----|-----|------|------|-----|-----|-----| 
|     |   0 |　0   | 0    | 0    |    0| 0    |
|  p  |    0 |     0 | 1     |     1 |  1    | 1     |
| e   |     0|     0 | 1    | 1     | 1    | 2    |
| o   |     0|   0   | 1    |  1    | 1    | 2    |
| p   |    0 |     0 | 1    | 2     |  2   | 2    |
| l   |     0|   0   | 1    | 2     | 3    |  3   |
| e   |     0|      |     |      |     |     |


第七行(`e`)  

|     |     |   a |   p  |  p  |  l  |  e  |
|-----|-----|------|------|-----|-----|-----| 
|     |   0 |　0   | 0    | 0    |    0| 0    |
|  p  |    0 |     0 | 1     |     1 |  1    | 1     |
| e   |     0|     0 | 1    | 1     | 1    | 2    |
| o   |     0|   0   | 1    |  1    | 1    | 2    |
| p   |    0 |     0 | 1    | 2     |  2   | 2    |
| l   |     0|   0   | 1    | 2     | 3    |  3   |
| e   |     0|   0   | 1    |  2    | 3    | $`\textcolor{red}{ 4}`$    |



**這樣我們就使用dp得到數組`dp[6][5]=4 `即答案  


#### code (java)  

```java
//核心
if(s1.charAt(i)==s2.charAt(j)){
  dp[i][j] = dp[i-1][j-1]+1;
}
else {
  dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
}
```

總而言之，恭喜你學完關於動態規劃中相當重要的一部份!  

